#!/bin/bash

# This file is part of the ZerusTech HTTP Cache Tutorial package.
#
# (c) Michael Lee <michael.lee@zerustech.com>
#
# For the full copyright and license information, please view the LICENSE file
# that was distributed with this source code.

base=`cd $(dirname $BASH_SOURCE) && pwd`

source "$base/../../lib/tty.sh"

# This script finds tasks by name and runs the tasks matched from command line.
#
# @author Michael Lee <michael.lee@zerustech.com>

# The command line usage of this script.
#
# Usage: usage
function usage()
{
    printf "task-all-run: usage: task-all-run [-av] [-l log_file] [-e task_exec] [-p path_pattern] [-n name_pattern] [-d depth|min+|min-max] path [task_arguments ...]\n"
    printf "The options are as follows:\n"
    printf "\t-a Run all tasks automatically.\n"
    printf "\t-v Run all tasks in verbose mode: display output from tasks to stdout.\n"
    printf "\t-s Run all tasks in scilent mode: hide output from tasks.\n"

    exit 1
}

# This function checks if the given path is a valid directory.
#
# Usage: test_directory <path>
#
# @param path The path to be tested.
# @return 0 if the path is a valid directory, 1 otherwise.
function test_directory()
{
    if [ ! -d $1 ]; then

        printf "Directory $1 does not exist!\n"

        exit 1

    fi
}

: ${task_exec:=""}
: ${log_file:="$base/../../var/task-all-run.log"}
: ${path_pattern:=""}
: ${name_pattern:=""}
: ${depth:=""}
: ${min_depth:=""}
: ${max_depth:=""}
: ${path:=""}
: ${verbose:="0"}
: ${interactive:="1"}
: ${tty:="`tty`"}

# reset OPTIND to 1, in case this script was sourced with no arguments.
OPTIND=1

while getopts "avsl:e:p:n:d:" opt; do

    case $opt in

        a) interactive=0;;

        v) verbose=1;;

        s) verbose=0;;

        l) log_file="$OPTARG";;

        e) task_exec="$OPTARG";;

        p) path_pattern="$OPTARG";;

        n) name_pattern="$OPTARG";;

        d) depth="$OPTARG";;

        *) usage;;

    esac

done

shift $((OPTIND -1))

if [ $# -gt 0 ]; then

   path=$1 && shift

fi

if [ "$path" == "" ]; then

   usage

fi

test_directory `dirname $log_file` && test_directory $path  || exit $?

find_options=""

if [ "$path_pattern" != "" ]; then

   find_options="${find_options}-path \"$path_pattern\" "

fi

if [ "$name_pattern" != "" ]; then

   find_options="${find_options}-name \"$name_pattern\" "

fi

if [ "$depth" != "" ] && [[ ! "$depth" =~ ^\+?[0-9]+$ ]] && [[ ! "$depth" =~ ^[0-9]+\-[0-9]+$ ]]; then

   usage

fi

if [[ "$depth" =~ ^([0-9]+)\-([0-9]+)$ ]]; then

   min_depth=${BASH_REMATCH[${#BASH_REMATCH[@]} - 2]}

   max_depth=${BASH_REMATCH[${#BASH_REMATCH[@]} - 1]}

   depth=""

fi

if [ "$depth" != "" ]; then

   find_options="${find_options}-depth $depth "

fi

if [ "$min_depth" != "" ]; then

   find_options="${find_options}-mindepth $min_depth "

fi

if [ "$max_depth" != "" ]; then

   find_options="${find_options}-maxdepth $max_depth "

fi

find_options="${find_options} -print0"

# Either 'bash -c' or 'eval' can be used to dynamically construct command
bash -c "find \"$path\" $find_options" | while IFS= read -r -d "" file ; do

    source "$base/task-run" "$file" "$@"

done
