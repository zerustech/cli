#!/bin/bash

# This file is part of the ZerusTech HTTP Cache Tutorial package.
#
# (c) Michael Lee <michael.lee@zerustech.com>
#
# For the full copyright and license information, please view the LICENSE file 
# that was distributed with this source code.

base=`cd $(dirname $BASH_SOURCE) && pwd`

source "$base/../../lib/tty.sh"

# This script runs tasks from command line.
# 
# @author Michael Lee <michael.lee@zerustech.com>

# The command line usage of this script.
# 
# Usage: usage
function usage()
{
    printf "tasks.run: usage: tasks.run [-iasv] [-c command] -S script_name_pattern -l log_file task_directory\n"
    printf "The options are as follows:\n"
    printf "\t-i - Request confirming before running each task.\n"
    printf "\t-a Run all tasks automatically.\n"
    printf "\t-s Run all tasks in silent mode (default): do not display any output from the tasks.\n"
    printf "\t-v Run all tasks in verbose mode: display output from tasks to stdout.\n"

    exit 0
}

# This function checks if the given path is a valid directory.
# 
# Usage: test_directory <path>
#
# @param path The path to be tested.
# @return 0 if the path is a valid directory, 1 otherwise.
function test_directory()
{
    if [ ! -d $1 ]; then

        printf "Directory $1 does not exist!\n"

        exit 1

    fi
}

log_file=""
verbose=0
interactive=1
task_base=""
script_name_pattern=""
command=""

if [ $# == 0 ]; then

    usage

fi

while getopts "iasvc:S:l:" opt; do

    case $opt in

        i) interactive=1;;

        a) interactive=0;;

        s) verbose=0;;

        v) verbose=1;;

        c) command="$OPTARG";;

        S) script_name_pattern="$OPTARG";;

        l) log_file="$OPTARG";;

        *) usage;;

    esac

done

shift $((OPTIND -1))

if [ "$script_name_pattern" == "" ] || [ "$log_file" == "" ]; then

   usage

fi

task_base=$1

test_directory `dirname $log_file` && test_directory $task_base  || exit $?

for f in `find $task_base -name "$script_name_pattern"`

do
    full_path=`cd -P $(dirname $f) && pwd`/`basename "$f"`

    run=0

    if [ "$interactive" == "1" ]; then

        tty_printf -f yellow "%s " $full_path

        printf "Do you want to run it ? (y/n)"

        old=`stty -g < $(tty)`

        # disable echo and icanon for current tty.
        stty -echo -icanon min 1 time 0 < `tty`

        # read only 1 character, so no need to press enter.
        read -n 1 answer

        # restore the original tty configuration.
        stty "$old" < `tty`

        if [ "$answer" == "y" ]; then

            if [ "$verbose" == "1" ]; then

                tty_printf "\n\n"

            fi

            run=1

        else 

            tty_printf " ... "

            tty_printf -f green "[skip]\n"

        fi

    else

        if [ "$verbose" == "1" ]; then

            tty_printf -f yellow "Running %s ... \n" $full_path

        else

            tty_printf -f yellow "%s " $full_path

        fi

        run=1

    fi

    if [ "$run" == "0" ]; then

        continue

    fi

    if [ "$verbose" == "1" ]; then

        $command $f | tee $log_file

    else

        tty_printf " ... " $f

        $command $f >> $log_file 2>&1

        tty_printf -f green "[done]\n"

    fi

done
